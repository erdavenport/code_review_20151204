#!/usr/bin/env Rscript

######  
suppressMessages(library("docopt"))
"
Usage: 
	beta_diversity_permutations_one_twin_120115ERD.R -h | --help
	beta_diversity_permutations_one_twin_120115ERD.R --abo_file=<abo_file> --cov_file=<cov_file> --bc_file=<bc_file> --uu_file=<uu_file> --wu_file=<wu_file> --n=<n> --nproc=<nproc> --outpath=<outpath>

Description: This script will calculate a permutation p-value for beta-diversity differences within and between groups for ABO and SS (one twin only). 

Options:
	-h  --help			print arguments to screen
	--abo_file=<abo_file> 		file of phenotype data
	--cov_file=<cov_file> 		file of covariate information
	--bc_file=<bc_file>			file of bray curtis dissimilarity
	--uu_file=<uu_file>			file of unweighted unifrac distances
	--wu_file=<wu_file>			file of weighted unifrac distances
	--n=<n>						number of permutations to run (each perm takes 1.3s)
	--nproc=<nproc>				number of processors to use in parallel (4 on computer)
	--outpath=<outpath> 		directory to write results to
" -> doc
######

###### PARAMETERS ##########
# Set the parameters:
today <- Sys.Date()											# Set the date that will go on the end of the files generated by this script
today <- format(today, format="%m%d%y")
#############################



##### Load arguments:
opts <- docopt(doc)
#print(opts)
abo.file <- opts$abo_file
cov.file <- opts$cov_file
bc.file <- opts$bc_file
uu.file <- opts$uu_file
wu.file <- opts$wu_file
n <- as.numeric(opts$n)
nproc <- as.numeric(opts$nproc)
outpath <- opts$outpath

abo.file <- "../results/pABO/abo.table.pABO.txt"
cov.file <- "../results/pABO/covs.table.pABO.txt"
bc.file <- "../results/pABO/beta.div.bc.pABO.txt"
wu.file <- "../results/pABO/beta.div.wu.pABO.txt"
uu.file <- "../results/pABO/beta.div.uu.pABO.txt"
n <- 100
nproc <- 4
outpath <- "../results/pABO/8_beta_diversity/"



##### Load libraries:
library("testit")
suppressMessages(library("foreach"))
suppressMessages(library("doParallel"))
library("reshape2")



##### Load data:
print("loading data")
abo <- read.table(file=abo.file, header=TRUE, stringsAsFactors=FALSE)
covs <- read.table(file=cov.file, header=TRUE, stringsAsFactors=FALSE)
bc <- read.table(file=bc.file, sep="\t", header=TRUE, stringsAsFactors=FALSE)
wu <- read.table(file=wu.file, sep="\t", header=TRUE, stringsAsFactors=FALSE)
uu <- read.table(file=uu.file, sep="\t", header=TRUE, stringsAsFactors=FALSE)



##### Generate output table if it isn't there already:
if (!file.exists(outpath)) {
	print(paste0("creating ",outpath," in filesystem"))
	dir.create(file.path(outpath))
}



##### Keep only one twin per family:
# Cut off that last number from TwinID so we have the pairs by number:
covs$i.TwinID <- substr(covs$i.TwinID, 1, nchar(covs$i.TwinID)-1)

# Remove one twin from each family:
rmme <- which(duplicated(covs[,"i.TwinID"]))
abo2 <- abo[-rmme,]
covs2 <- covs[-rmme,]

bc2 <- as.matrix(bc[-rmme, -rmme])
wu2 <- as.matrix(wu[-rmme, -rmme])
uu2 <- as.matrix(uu[-rmme, -rmme])



##### Function to create within and between groups for permutations:
groupme <- function(m) {
	if (is.na(m[1]) | is.na(m[2])) { # for missing SS individuals
		return(NA)
	} else if (m[1] == m[2]) {
		return("within")
	} else {
		return("between")
	}
}

groupme <- function(m) {
	if (m[1] == m[2]) {
		return("within")
	} else {
		return("between")
	}
}

##### Create melted distance table for each distance metric with either ABO or SS labels:

####### TRY NOT SETTING TO 999 
bc2[upper.tri(bc2, diag=TRUE)] <- 999
colnames(bc2) <- abo2$ABO
rownames(bc2) <- abo2$ABO
bc.abo.M <- subset(melt(bc2), value!=999)
#bc.abo.M <- subset(melt(bc2), !is.na(value))
colnames(bc2) <- abo2$secretor_status
rownames(bc2) <- abo2$secretor_status
bc.ss.M <- subset(melt(bc2), value!=999)

wu2[upper.tri(wu2, diag=TRUE)] <- 999
colnames(wu2) <- abo2$ABO
rownames(wu2) <- abo2$ABO
wu.abo.M <- subset(melt(wu2), value!=999)
colnames(wu2) <- abo2$secretor_status
rownames(wu2) <- abo2$secretor_status
wu.ss.M <- subset(melt(wu2), value!=999)

uu2[upper.tri(uu2, diag=TRUE)] <- 999
colnames(uu2) <- abo2$ABO
rownames(uu2) <- abo2$ABO
uu.abo.M <- subset(melt(uu2), value!=999)
colnames(uu2) <- abo2$secretor_status
rownames(uu2) <- abo2$secretor_status
uu.ss.M <- subset(melt(uu2), value!=999)



##### Calculate actual t-test p-value:

##### YO THIS:
result = ifelse(bc.ss.M$Var1 == bc.ss.M$Var2, "within", "between")
######

abo.group <- apply(bc.abo.M, 1, groupme)
ss.group <- apply(bc.ss.M, 1, groupme)

abo.bc.p <- t.test(bc.abo.M$value ~ abo.group)$p.value
ss.bc.p <- t.test(bc.ss.M$value ~ ss.group)$p.value

abo.wu.p <- t.test(wu.abo.M$value ~ abo.group)$p.value
ss.wu.p <- t.test(wu.ss.M$value ~ ss.group)$p.value

abo.uu.p <- t.test(uu.abo.M$value ~ abo.group)$p.value
ss.uu.p <- t.test(uu.ss.M$value ~ ss.group)$p.value

actual.ps <- c(abo.bc.p, ss.bc.p, abo.wu.p, ss.wu.p, abo.uu.p, ss.uu.p)



##### Run the permutations:
print("running permutations in parallel")
# Set up parallel backend to use 4 processors
cl <- makeCluster(nproc)
registerDoParallel(cl)



######### NOTES:
do a match to match individuals who were permuted to orig IDs
then do lookup with ABO/SS
Could be faster than the melt?

Update submission script to make sure they're going to the same machine
#########

# Start time:
strt <- Sys.time()

# mclapply
x <- foreach(j=1:n, .packages=c("reshape2")) %dopar% {
	set.seed(j)
	print(paste0("on permutation ",j, "of ",n))

	# Permute individual assignments:
	neword <- sample(1:dim(bc2)[2], dim(bc2)[2], replace=FALSE)
	
	# Reassign ABO status and find groups:
	colnames(bc2) <- abo2$ABO[neword]
	rownames(bc2) <- abo2$ABO[neword]
	bc2[upper.tri(bc2, diag=TRUE)] <- 999
	abo.M <- subset(melt(bc2), value!=999)
	abo.grps <- apply(abo.M, 1, groupme)
	
	# Reassign secretor status and find groups:
	colnames(bc2) <- abo2$secretor_status[neword]
	rownames(bc2) <- abo2$secretor_status[neword]
	bc2[upper.tri(bc2, diag=TRUE)] <- 999
	ss.M <- subset(melt(bc2), value!=999)
	ss.grps <- apply(ss.M, 1, groupme)
	
	# Calculate permutation p-values for each distance metric and ABO/SS:
	p1 <- t.test(bc.abo.M$value ~ abo.grps)$p.value
	p2 <- t.test(bc.abo.M$value ~ ss.grps)$p.value
	p3 <- t.test(wu.abo.M$value ~ abo.grps)$p.value
	p4 <- t.test(wu.abo.M$value ~ ss.grps)$p.value
	p5 <- t.test(uu.abo.M$value ~ abo.grps)$p.value
	p6 <- t.test(uu.abo.M$value ~ ss.grps)$p.value
	
	x <- c(p1, p2, p3, p4, p5, p6)
}
print(Sys.time() - strt)
stopCluster(cl)



##### Save table of permuted mean accuracies from the 5 fold cross validations:
print("calculating permutation p-values")
permutations <- matrix(unlist(x), ncol=6, byrow=TRUE)

colnames(permutations) <- c("bc_abo", "bc_ss", "wu_abo", "wu_ss", "uu_abo", "uu_ss")


##### Calculate permutation p-value:
allp <- rbind(actual.ps, permutations)

perm_p <- function(x) {
	p <- length(which(x[-1] <= x[1]))/length(x[-1])
	return(p)
}

permutation_p <- apply(allp, 2, perm_p)

all.ps <- rbind(permutation_p, allp)
rownames(all.ps)[1:2] <- c("permutation_p", "t.test_p")



##### Write out table:
print("writing out table of p-values")
write.table(all.ps, paste0(outpath, "beta_div_t_test_permutations_n_",n,"_",today,"ERD.txt"), sep="\t", quote=FALSE)



print("DONE!")


	